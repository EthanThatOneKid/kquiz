// Code generated by jtd-codegen for Go v0.2.1. DO NOT EDIT.

package qg

import (
	"encoding/json"
	"fmt"
)

type Qg = interface{}

type Command struct {
	Value ICommand `json:"-"`
}

func (v Command) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.Value)
}

func (v *Command) UnmarshalJSON(b []byte) error {
	var t struct {
		T string `json:"type"`
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var value ICommand
	var err error

	switch t.T {
	case "BeginGame":
		var v CommandBeginGame
		err = json.Unmarshal(b, &v)
		value = v
	case "EndGame":
		var v CommandEndGame
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyChooseQuestion":
		var v CommandJeopardyChooseQuestion
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyPlayerJudgment":
		var v CommandJeopardyPlayerJudgment
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyPressButton":
		var v CommandJeopardyPressButton
		err = json.Unmarshal(b, &v)
		value = v
	case "JoinGame":
		var v CommandJoinGame
		err = json.Unmarshal(b, &v)
		value = v
	default:
		err = fmt.Errorf("Command: bad type value: %q", t.T)
	}

	if err != nil {
		return err
	}

	v.Value = value
	return nil
}

// ICommand is an interface type that Command types implement.
// It can be the following types:
//
// - [CommandBeginGame] (BeginGame)
// - [CommandEndGame] (EndGame)
// - [CommandJeopardyChooseQuestion] (JeopardyChooseQuestion)
// - [CommandJeopardyPlayerJudgment] (JeopardyPlayerJudgment)
// - [CommandJeopardyPressButton] (JeopardyPressButton)
// - [CommandJoinGame] (JoinGame)
type ICommand interface {
	Type() string
	isCommand()
}

func (CommandBeginGame) Type() string              { return "BeginGame" }
func (CommandEndGame) Type() string                { return "EndGame" }
func (CommandJeopardyChooseQuestion) Type() string { return "JeopardyChooseQuestion" }
func (CommandJeopardyPlayerJudgment) Type() string { return "JeopardyPlayerJudgment" }
func (CommandJeopardyPressButton) Type() string    { return "JeopardyPressButton" }
func (CommandJoinGame) Type() string               { return "JoinGame" }

func (CommandBeginGame) isCommand()              {}
func (CommandEndGame) isCommand()                {}
func (CommandJeopardyChooseQuestion) isCommand() {}
func (CommandJeopardyPlayerJudgment) isCommand() {}
func (CommandJeopardyPressButton) isCommand()    {}
func (CommandJoinGame) isCommand()               {}

func (v CommandBeginGame) MarshalJSON() ([]byte, error) {
	type Alias CommandBeginGame
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandBeginGame) UnmarshalJSON(b []byte) error {
	type Alias CommandBeginGame
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "BeginGame" {
		return fmt.Errorf("CommandBeginGame: bad type value: %q", a.T)
	}

	*v = CommandBeginGame(a.Alias)
	return nil
}

func (v CommandEndGame) MarshalJSON() ([]byte, error) {
	type Alias CommandEndGame
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandEndGame) UnmarshalJSON(b []byte) error {
	type Alias CommandEndGame
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "EndGame" {
		return fmt.Errorf("CommandEndGame: bad type value: %q", a.T)
	}

	*v = CommandEndGame(a.Alias)
	return nil
}

func (v CommandJeopardyChooseQuestion) MarshalJSON() ([]byte, error) {
	type Alias CommandJeopardyChooseQuestion
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandJeopardyChooseQuestion) UnmarshalJSON(b []byte) error {
	type Alias CommandJeopardyChooseQuestion
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyChooseQuestion" {
		return fmt.Errorf("CommandJeopardyChooseQuestion: bad type value: %q", a.T)
	}

	*v = CommandJeopardyChooseQuestion(a.Alias)
	return nil
}

func (v CommandJeopardyPlayerJudgment) MarshalJSON() ([]byte, error) {
	type Alias CommandJeopardyPlayerJudgment
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandJeopardyPlayerJudgment) UnmarshalJSON(b []byte) error {
	type Alias CommandJeopardyPlayerJudgment
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyPlayerJudgment" {
		return fmt.Errorf("CommandJeopardyPlayerJudgment: bad type value: %q", a.T)
	}

	*v = CommandJeopardyPlayerJudgment(a.Alias)
	return nil
}

func (v CommandJeopardyPressButton) MarshalJSON() ([]byte, error) {
	type Alias CommandJeopardyPressButton
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandJeopardyPressButton) UnmarshalJSON(b []byte) error {
	type Alias CommandJeopardyPressButton
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyPressButton" {
		return fmt.Errorf("CommandJeopardyPressButton: bad type value: %q", a.T)
	}

	*v = CommandJeopardyPressButton(a.Alias)
	return nil
}

func (v CommandJoinGame) MarshalJSON() ([]byte, error) {
	type Alias CommandJoinGame
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *CommandJoinGame) UnmarshalJSON(b []byte) error {
	type Alias CommandJoinGame
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JoinGame" {
		return fmt.Errorf("CommandJoinGame: bad type value: %q", a.T)
	}

	*v = CommandJoinGame(a.Alias)
	return nil
}

// CommandBeginGame is sent by a client to begin a game.
type CommandBeginGame struct {
}

// CommandEndGame is sent by a client to end the current game. The server
// will respond with an EventGameEnded. Only game admins (including the
// host) can end the game.
type CommandEndGame struct {
	// declareWinner determines whether the game should be ended with a
	// winner or not. If true, the game will be ended with a winner. If
	// false, the game will be ended abruptly.
	DeclareWinner bool `json:"declareWinner"`
}

// CommandJeopardyChooseQuestion is sent by a player to choose a question.
// The server must do validation to ensure that the player is allowed to
// choose the question.
type CommandJeopardyChooseQuestion struct {
	Category int32 `json:"category"`

	Question int32 `json:"question"`
}

// CommandJeopardyPlayerJudgment is emitted by a game admin to indicate
// whether a player has answered a question correctly. The winning player is
// whoever the last EventJeopardyButtonPressed event indicated. That player
// will instantly receive the points for the question, and the game will let
// them choose the next category and question. If the player answered wrong,
// then the game will let others press the button.
type CommandJeopardyPlayerJudgment struct {
	Correct bool `json:"correct"`
}

// CommandJeopardyPressButton is emitted when a player presses the button
// during a question. It is only valid to emit this command when the game is
// in the question state.
type CommandJeopardyPressButton struct {
}

// CommandJoinGame is sent by a client to join a game. The client (or the
// user) supplies a game ID and a player name. The server will respond with
// an EventJoinedGame.
type CommandJoinGame struct {
	// adminPassword is the password of the admin of the game.
	AdminPassword *string `json:"adminPassword"`

	// gameID is the ID of the game to join.
	GameID GameID `json:"gameID"`

	// playerName is the wanted name of the user.
	PlayerName PlayerName `json:"playerName"`
}

// Error is returned on every API error.
type Error struct {
	// Message is the error message
	Message string `json:"message"`
}

type Event struct {
	Value IEvent `json:"-"`
}

func (v Event) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.Value)
}

func (v *Event) UnmarshalJSON(b []byte) error {
	var t struct {
		T string `json:"type"`
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var value IEvent
	var err error

	switch t.T {
	case "Error":
		var v EventError
		err = json.Unmarshal(b, &v)
		value = v
	case "GameEnded":
		var v EventGameEnded
		err = json.Unmarshal(b, &v)
		value = v
	case "GameStarted":
		var v EventGameStarted
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyBeginQuestion":
		var v EventJeopardyBeginQuestion
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyButtonPressed":
		var v EventJeopardyButtonPressed
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyResumeButton":
		var v EventJeopardyResumeButton
		err = json.Unmarshal(b, &v)
		value = v
	case "JeopardyTurnEnded":
		var v EventJeopardyTurnEnded
		err = json.Unmarshal(b, &v)
		value = v
	case "JoinedGame":
		var v EventJoinedGame
		err = json.Unmarshal(b, &v)
		value = v
	case "PlayerJoined":
		var v EventPlayerJoined
		err = json.Unmarshal(b, &v)
		value = v
	default:
		err = fmt.Errorf("Event: bad type value: %q", t.T)
	}

	if err != nil {
		return err
	}

	v.Value = value
	return nil
}

// IEvent is an interface type that Event types implement.
// It can be the following types:
//
// - [EventError] (Error)
// - [EventGameEnded] (GameEnded)
// - [EventGameStarted] (GameStarted)
// - [EventJeopardyBeginQuestion] (JeopardyBeginQuestion)
// - [EventJeopardyButtonPressed] (JeopardyButtonPressed)
// - [EventJeopardyResumeButton] (JeopardyResumeButton)
// - [EventJeopardyTurnEnded] (JeopardyTurnEnded)
// - [EventJoinedGame] (JoinedGame)
// - [EventPlayerJoined] (PlayerJoined)
type IEvent interface {
	Type() string
	isEvent()
}

func (EventError) Type() string                 { return "Error" }
func (EventGameEnded) Type() string             { return "GameEnded" }
func (EventGameStarted) Type() string           { return "GameStarted" }
func (EventJeopardyBeginQuestion) Type() string { return "JeopardyBeginQuestion" }
func (EventJeopardyButtonPressed) Type() string { return "JeopardyButtonPressed" }
func (EventJeopardyResumeButton) Type() string  { return "JeopardyResumeButton" }
func (EventJeopardyTurnEnded) Type() string     { return "JeopardyTurnEnded" }
func (EventJoinedGame) Type() string            { return "JoinedGame" }
func (EventPlayerJoined) Type() string          { return "PlayerJoined" }

func (EventError) isEvent()                 {}
func (EventGameEnded) isEvent()             {}
func (EventGameStarted) isEvent()           {}
func (EventJeopardyBeginQuestion) isEvent() {}
func (EventJeopardyButtonPressed) isEvent() {}
func (EventJeopardyResumeButton) isEvent()  {}
func (EventJeopardyTurnEnded) isEvent()     {}
func (EventJoinedGame) isEvent()            {}
func (EventPlayerJoined) isEvent()          {}

func (v EventError) MarshalJSON() ([]byte, error) {
	type Alias EventError
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventError) UnmarshalJSON(b []byte) error {
	type Alias EventError
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "Error" {
		return fmt.Errorf("EventError: bad type value: %q", a.T)
	}

	*v = EventError(a.Alias)
	return nil
}

func (v EventGameEnded) MarshalJSON() ([]byte, error) {
	type Alias EventGameEnded
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventGameEnded) UnmarshalJSON(b []byte) error {
	type Alias EventGameEnded
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "GameEnded" {
		return fmt.Errorf("EventGameEnded: bad type value: %q", a.T)
	}

	*v = EventGameEnded(a.Alias)
	return nil
}

func (v EventGameStarted) MarshalJSON() ([]byte, error) {
	type Alias EventGameStarted
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventGameStarted) UnmarshalJSON(b []byte) error {
	type Alias EventGameStarted
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "GameStarted" {
		return fmt.Errorf("EventGameStarted: bad type value: %q", a.T)
	}

	*v = EventGameStarted(a.Alias)
	return nil
}

func (v EventJeopardyBeginQuestion) MarshalJSON() ([]byte, error) {
	type Alias EventJeopardyBeginQuestion
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventJeopardyBeginQuestion) UnmarshalJSON(b []byte) error {
	type Alias EventJeopardyBeginQuestion
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyBeginQuestion" {
		return fmt.Errorf("EventJeopardyBeginQuestion: bad type value: %q", a.T)
	}

	*v = EventJeopardyBeginQuestion(a.Alias)
	return nil
}

func (v EventJeopardyButtonPressed) MarshalJSON() ([]byte, error) {
	type Alias EventJeopardyButtonPressed
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventJeopardyButtonPressed) UnmarshalJSON(b []byte) error {
	type Alias EventJeopardyButtonPressed
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyButtonPressed" {
		return fmt.Errorf("EventJeopardyButtonPressed: bad type value: %q", a.T)
	}

	*v = EventJeopardyButtonPressed(a.Alias)
	return nil
}

func (v EventJeopardyResumeButton) MarshalJSON() ([]byte, error) {
	type Alias EventJeopardyResumeButton
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventJeopardyResumeButton) UnmarshalJSON(b []byte) error {
	type Alias EventJeopardyResumeButton
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyResumeButton" {
		return fmt.Errorf("EventJeopardyResumeButton: bad type value: %q", a.T)
	}

	*v = EventJeopardyResumeButton(a.Alias)
	return nil
}

func (v EventJeopardyTurnEnded) MarshalJSON() ([]byte, error) {
	type Alias EventJeopardyTurnEnded
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventJeopardyTurnEnded) UnmarshalJSON(b []byte) error {
	type Alias EventJeopardyTurnEnded
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JeopardyTurnEnded" {
		return fmt.Errorf("EventJeopardyTurnEnded: bad type value: %q", a.T)
	}

	*v = EventJeopardyTurnEnded(a.Alias)
	return nil
}

func (v EventJoinedGame) MarshalJSON() ([]byte, error) {
	type Alias EventJoinedGame
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventJoinedGame) UnmarshalJSON(b []byte) error {
	type Alias EventJoinedGame
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "JoinedGame" {
		return fmt.Errorf("EventJoinedGame: bad type value: %q", a.T)
	}

	*v = EventJoinedGame(a.Alias)
	return nil
}

func (v EventPlayerJoined) MarshalJSON() ([]byte, error) {
	type Alias EventPlayerJoined
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *EventPlayerJoined) UnmarshalJSON(b []byte) error {
	type Alias EventPlayerJoined
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "PlayerJoined" {
		return fmt.Errorf("EventPlayerJoined: bad type value: %q", a.T)
	}

	*v = EventPlayerJoined(a.Alias)
	return nil
}

type EventError struct {
	Error Error `json:"error"`
}

// EventGameEnded is emitted when the current game ends.
type EventGameEnded struct {
	Leaderboard Leaderboard `json:"leaderboard"`
}

// EventGameStarted is emitted when the game starts. It contains no data and
// is only meant to be used to trigger the client to start the game.
type EventGameStarted struct {
}

// EventJeopardyBeginQuestion is emitted when a question begins within this
// Jeopardy game. It is usually emitted once the chooser player has chosen a
// category and value.
//
// Each category name and question value will map to a category and question
// within the game data. Note that a question may repeat across multiple
// categories.
type EventJeopardyBeginQuestion struct {
	Category int32 `json:"category"`

	Chooser PlayerName `json:"chooser"`

	Points float32 `json:"points"`

	Question string `json:"question"`
}

// EventJeopardyButtonPressed is emitted when any player had pressed a button
// on their device, voiding other players' buttons. This event is only
// emitted when the game is in the "question" state.
type EventJeopardyButtonPressed struct {
	PlayerName PlayerName `json:"playerName"`
}

// EventJeopardyResumeButton is emitted when the player can now continue to
// press the button whenever they are ready to answer the question. This
// could happen if the other player who pressed the button first got the
// question wrong.
//
// Note that if alreadyPressed is true, then the player has already pressed
// the button, so they cannot press it again.
type EventJeopardyResumeButton struct {
	AlreadyAnsweredPlayers []PlayerName `json:"alreadyAnsweredPlayers"`
}

// EventJeopardyTurnEnded is emitted when a turn ends or when the game first
// starts.
type EventJeopardyTurnEnded struct {
	Chooser PlayerName `json:"chooser"`

	Leaderboard Leaderboard `json:"leaderboard"`
}

// EventJoinedGame is emitted when the current player joins a game. It is a
// reply to CommandJoinGame and is only for the current player. Not to be
// confused with EventPlayerJoinedGame, which is emitted when any player
// joins the current game.
type EventJoinedGame struct {
	GameData *GameData `json:"gameData"`

	GameID string `json:"gameID"`

	GameInfo GameInfo `json:"gameInfo"`

	IsAdmin bool `json:"isAdmin"`
}

// EventPlayerJoined is emitted when a player joins the current game.
type EventPlayerJoined struct {
	PlayerName PlayerName `json:"playerName"`
}

// GameData is the game data. It contains all the information about the game.
type GameData struct {
	Value IGameData `json:"-"`
}

func (v GameData) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.Value)
}

func (v *GameData) UnmarshalJSON(b []byte) error {
	var t struct {
		T string `json:"game"`
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var value IGameData
	var err error

	switch t.T {
	case "jeopardy":
		var v GameDataJeopardy
		err = json.Unmarshal(b, &v)
		value = v
	case "kahoot":
		var v GameDataKahoot
		err = json.Unmarshal(b, &v)
		value = v
	default:
		err = fmt.Errorf("GameData: bad game value: %q", t.T)
	}

	if err != nil {
		return err
	}

	v.Value = value
	return nil
}

// IGameData is an interface type that GameData types implement.
// It can be the following types:
//
// - [GameDataJeopardy] (jeopardy)
// - [GameDataKahoot] (kahoot)
type IGameData interface {
	Game() string
	isGameData()
}

func (GameDataJeopardy) Game() string { return "jeopardy" }
func (GameDataKahoot) Game() string   { return "kahoot" }

func (GameDataJeopardy) isGameData() {}
func (GameDataKahoot) isGameData()   {}

func (v GameDataJeopardy) MarshalJSON() ([]byte, error) {
	type Alias GameDataJeopardy
	return json.Marshal(struct {
		T string `json:"game"`
		Alias
	}{
		v.Game(),
		Alias(v),
	})
}

func (v *GameDataJeopardy) UnmarshalJSON(b []byte) error {
	type Alias GameDataJeopardy
	var a struct {
		T string `json:"game"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "jeopardy" {
		return fmt.Errorf("GameDataJeopardy: bad game value: %q", a.T)
	}

	*v = GameDataJeopardy(a.Alias)
	return nil
}

func (v GameDataKahoot) MarshalJSON() ([]byte, error) {
	type Alias GameDataKahoot
	return json.Marshal(struct {
		T string `json:"game"`
		Alias
	}{
		v.Game(),
		Alias(v),
	})
}

func (v *GameDataKahoot) UnmarshalJSON(b []byte) error {
	type Alias GameDataKahoot
	var a struct {
		T string `json:"game"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "kahoot" {
		return fmt.Errorf("GameDataKahoot: bad game value: %q", a.T)
	}

	*v = GameDataKahoot(a.Alias)
	return nil
}

type GameDataJeopardy struct {
	Data JeopardyGameData `json:"data"`
}

type GameDataKahoot struct {
	Data KahootGameData `json:"data"`
}

// GameID is the unique identifier for a game. Each player must type this
// code to join the game.
type GameID = string

type GameInfo struct {
	Value IGameInfo `json:"-"`
}

func (v GameInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.Value)
}

func (v *GameInfo) UnmarshalJSON(b []byte) error {
	var t struct {
		T string `json:"type"`
	}
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var value IGameInfo
	var err error

	switch t.T {
	case "jeopardy":
		var v GameInfoJeopardy
		err = json.Unmarshal(b, &v)
		value = v
	default:
		err = fmt.Errorf("GameInfo: bad type value: %q", t.T)
	}

	if err != nil {
		return err
	}

	v.Value = value
	return nil
}

// IGameInfo is an interface type that GameInfo types implement.
// It can be the following types:
//
// - [GameInfoJeopardy] (jeopardy)
type IGameInfo interface {
	Type() string
	isGameInfo()
}

func (GameInfoJeopardy) Type() string { return "jeopardy" }

func (GameInfoJeopardy) isGameInfo() {}

func (v GameInfoJeopardy) MarshalJSON() ([]byte, error) {
	type Alias GameInfoJeopardy
	return json.Marshal(struct {
		T string `json:"type"`
		Alias
	}{
		v.Type(),
		Alias(v),
	})
}

func (v *GameInfoJeopardy) UnmarshalJSON(b []byte) error {
	type Alias GameInfoJeopardy
	var a struct {
		T string `json:"type"`
		Alias
	}

	if err := json.Unmarshal(b, &a); err != nil {
		return err
	}

	if a.T != "jeopardy" {
		return fmt.Errorf("GameInfoJeopardy: bad type value: %q", a.T)
	}

	*v = GameInfoJeopardy(a.Alias)
	return nil
}

type GameInfoJeopardy struct {
	Data JeopardyGameInfo `json:"data"`
}

type GameType string

const (
	GameTypeJeopardy GameType = "jeopardy"

	GameTypeKahoot GameType = "kahoot"
)

// JeopardyCategory is a category in a Jeopardy game.
type JeopardyCategory struct {
	// name is the name of the category.
	Name string `json:"name"`

	// questions are the questions in the category.
	Questions []JeopardyQuestion `json:"questions"`
}

// JeopardyGameData is the game data for a Jeopardy game.
type JeopardyGameData struct {
	Categories []JeopardyCategory `json:"categories"`

	// score_multiplier is the score multiplier for each question. The
	// default is 100.
	ScoreMultiplier *float32 `json:"score_multiplier,omitempty"`
}

// JeopardyGameInfo is the initial information for a Jeopardy game. This type
// contains no useful information about the entire game data, so it's used to
// send to players the first time they join.
type JeopardyGameInfo struct {
	Categories []string `json:"categories"`

	NumQuestions int32 `json:"numQuestions"`

	ScoreMultiplier float32 `json:"scoreMultiplier"`
}

// JeopardyQuestion is a question in a Jeopardy game.
type JeopardyQuestion struct {
	// question is the question.
	Question string `json:"question"`
}

// KahootGameData is the game data for a Kahoot game.
type KahootGameData struct {
	// questions are the questions in the game.
	Questions []KahootQuestion `json:"questions"`

	// time_limit is the time limit for each question. The format is in
	// Go's time.Duration, e.g. 10s for 10 seconds.
	TimeLimit string `json:"time_limit"`
}

// KahootQuestion is a question in a Kahoot game.
type KahootQuestion struct {
	// answers are the possible answers.
	Answers []string `json:"answers"`

	// question is the question.
	Question string `json:"question"`
}

// Leaderboard is a list of players and their scores.
type Leaderboard = []LeaderboardEntry

type LeaderboardEntry struct {
	PlayerName string `json:"playerName"`

	Score float32 `json:"score"`
}

// PlayerName is the name of a player.
type PlayerName = string

type RequestGetGame struct {
	GameID string `json:"gameID"`
}

type RequestGetJeopardyGame struct {
	GameID string `json:"gameID"`
}

type RequestNewGame struct {
	AdminPassword string `json:"admin_password"`

	Data GameData `json:"data"`
}

type ResponseGetGame struct {
	GameType GameType `json:"gameType"`
}

type ResponseGetJeopardyGame struct {
	Info JeopardyGameInfo `json:"info"`
}

type ResponseNewGame struct {
	GameID string `json:"gameID"`

	GameType GameType `json:"gameType"`
}
